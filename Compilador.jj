options {
  STATIC = false;
  DEBUG_PARSER = false;
  DEBUG_TOKEN_MANAGER = false;
  LOOKAHEAD = 2;  // Aumentamos el lookahead global para resolver conflictos
}

PARSER_BEGIN(Compilador)

import java.util.*;
import java.io.*;


public class Compilador {
  // Tabla de símbolos para almacenar variables y sus tipos
  static HashMap<String, String> tablaSimbolos = new HashMap<String, String>();
  // Lista para almacenar errores semánticos
  static ArrayList<String> erroresSemanticos = new ArrayList<String>();
  // Lista para almacenar errores léxicos
  static ArrayList<String> tablaErrores = new ArrayList<String>();

// Raíz del AST
  private NodoAST astRaiz;

  class NodoAST {
      private String valor;
      private String tipo;
      private ArrayList<NodoAST> hijos;

      public NodoAST(String valor, String tipo) {
          this.valor = valor;
          this.tipo = tipo;
          this.hijos = new ArrayList<NodoAST>();
      }

      public void agregarHijo(NodoAST hijo) {
          this.hijos.add(hijo);
      }

      public String getValor() {
          return valor;
      }

      public String getTipo() {
          return tipo;
      }

      public ArrayList<NodoAST> getHijos() {
          return hijos;
      }

      public void imprimirArbol(int nivel) {
          String indentacion = "";
          for (int i = 0; i < nivel; i++) {
              indentacion += "  ";
          }
          System.out.println(indentacion + tipo + ": " + valor);
          for (NodoAST hijo : hijos) {
              hijo.imprimirArbol(nivel + 1);
          }
      }
  }

  public static void main(String args[]) throws ParseException {
    try {
      Compilador parser = new Compilador(new FileInputStream(args[0]));
      parser.programa(); // Llamamos al parser
      System.out.println("Análisis completado con éxito.");

      // Imprimir el AST
      if (parser.astRaiz != null) {
        System.out.println("\nÁrbol Sintáctico Abstracto:");
        parser.astRaiz.imprimirArbol(0);
      }

      // Mostrar tabla de símbolos
      System.out.println("\nTabla de símbolos:");
      for (Map.Entry<String, String> entry : tablaSimbolos.entrySet()) {
        System.out.println("Variable: " + entry.getKey() + ", Tipo: " + entry.getValue());
      }

      // Mostrar errores semánticos
      if (!erroresSemanticos.isEmpty()) {
        System.out.println("\nErrores semánticos encontrados:");
        for (String error : erroresSemanticos) {
          System.out.println(error);
        }
      }

      // Mostrar errores léxicos
      if (!tablaErrores.isEmpty()) {
        System.out.println("\nErrores léxicos encontrados:");
        for (String error : tablaErrores) {
          System.out.println(error);
        }
      }
    } catch (FileNotFoundException e) {
      System.out.println("Archivo no encontrado: " + e.getMessage());
    } catch (ParseException e) {
      System.out.println("Error de sintaxis: " + e.getMessage());
    }
  }

  // Método para verificar si una variable ya está declarada
  private static boolean existeVariable(String nombre) {
    return tablaSimbolos.containsKey(nombre);
  }

  // Método para agregar una variable a la tabla de símbolos
  private static void agregarVariable(String nombre, String tipo) {
    tablaSimbolos.put(nombre, tipo);
  }

  // Método para verificar compatibilidad de tipos
  private static boolean sonTiposCompatibles(String tipoVar, String tipoValor) {
    if (tipoVar.equals(tipoValor)) return true;
    if (tipoVar.equals("flot") && tipoValor.equals("ent")) return true;
    return false;
  }

  // Método para obtener el tipo de una variable
  private static String obtenerTipo(String nombre) {
    return tablaSimbolos.get(nombre);
  }

  // Método para obtener el tipo de un valor literal
  private static String obtenerTipoValor(Token token) {
    if (token.kind == ENTEROS) return "ent";
    if (token.kind == NUMERODECIMAL) return "flot";
    if (token.kind == VCAD) return "cad";
    return "desconocido";
  }

  // Método para agregar un error semántico
  private static void agregarErrorSemantico(String mensaje) {
    erroresSemanticos.add(mensaje);
  }

  // Método para agregar un error léxico
  private static void agregarErrorLexico(String mensaje) {
    tablaErrores.add(mensaje);
  }
}

PARSER_END(Compilador)

// Tokens a ignorar
SKIP: { " " |"\t" |"\r" }
SPECIAL_TOKEN: { "\n" }

// Definición de tokens
TOKEN: //Variables
{
  <ENT: "ent"> |
  <FLOT: "flot"> |
  <BOOL: "bool"> |
  <CAD: "cad"> |
  <VAR: "var">
}

TOKEN: //Operadores Logicos-Aritmeticos
{
  <MAS: "mas"> |
  <MENOS: "menos"> |
  <MULT: "mult"> |
  <DIV: "div"> |
  <RES: "res"> |
  <INC: "inc"> |
  <DEC: "dec"> |
  <AND: "AND"> |
  <OR: "OR"> |
  <NOT: "NOT">
}

TOKEN: //Comparadores
{
  <IGUALDAD: "=="> |
  <IGUAL: "="> |
  <DESIGUALDAD: "!="> |
  <MAYOR: ">"> |
  <MENOR: "<"> |
  <MAYORIGUAL: ">="> |
  <MENORIGUAL: "<=">
}

TOKEN: //DIGITOS
{
  <ENTEROS: (["0"-"9"])+> |
  <NUMERODECIMAL: (["0"-"9"])*("."["0"-"9"]["0"-"9"])|(["0"-"9"])*("."["0"-"9"])+>
}

TOKEN: //CICLOS
{
  <FOR: "for"> |
  <WHILE: "while">
}

TOKEN: //ARREGLOS
{
  <MATRIZ: "matrix"> |
  <VECTOR: "vec">
}

TOKEN: //CONDICIONALES
{
  <SI: "SI"> |
  <SINO: "SINO">
}

TOKEN: //LECTURA
{
  <LEER: "leer">
}

TOKEN: //ESCRITURA
{
  <ESCRIBIR: "escribir">
}

TOKEN: //SIMBOLOS DE DELIMITACION
{
  <PUNTO: "."> |
  <DELIMITADOR: ";"> |
  <COMA: ","> |
  <CORCHIZQ: "["> |
  <CORCHDER: "]"> |
  <LLAVEIZQ: "{"> |
  <LLAVEDER: "}"> |
  <PARENIZQ: "("> |
  <PARENDER: ")"> |
  <CONCATENAR: "+">
}

TOKEN: //Palabras Reservadas
{
  <VOID: "void"> |
  <PUBLICO: "publico"> |
  <PRIVADO: "privado"> |
  <ESTATICO: "estatico"> |
  <RETURN: "return">
}

TOKEN:
{
  <MATH: "Math"> |
  <ARRAYCLASS: "Array"> |
  <RANDOMCLASS: "Random"> |
  <TIMERCLASS: "Timer">
}

TOKEN: //FUNCIONES DE CLASES
{
  <RAMDONFUNC: (<RANDOMCLASS>)"."("next"|"equals")> |
  <ARRAYFUNC: (<ARRAYCLASS>)"."("clear"|"clone"|"copy"|"reverse")> |
  <TIMERFUNC: (<TIMERCLASS>)"."("start"|"stop")> |
  <MATHFUNC: (<MATH>)"."("abs"|"acos"|"acosh"|"tan"|"cos"|"sen"|"random"|"sqrt")> |
  <INICIO: "Inicio"> |
  <FIN: "Fin"> |
  <MAIN: "Main"|"main"> |
  <PROC: "proc"> |
  <FUNC: "func">
}

TOKEN: // IDENTIFICADOR
{
  <IDENTIFICADOR: ["a"-"z", "A"-"Z"](["a"-"z", "A"-"Z", "0"-"9", "_"])*>
}

TOKEN: //Reconocimiento de valores
{
  <VCAD: "\""(["a"-"z"]|["A"-"Z"]|["0"-"9"]|[","]|["."]|[" "]|[":"]|["="])+"\"">
}

TOKEN: // Manejo de Errores
{
  <ERROR: ~[]>
}

// Definición de la gramática - Análisis Sintáctico
NodoAST programa() :
{ NodoAST raiz = new NodoAST("programa", "programa"); NodoAST subNodo; }
{
  <INICIO> <MAIN> <LLAVEIZQ>
  (
    (subNodo = declaracion() { raiz.agregarHijo(subNodo); }) |
    (subNodo = asignacion() { raiz.agregarHijo(subNodo); }) |
    (subNodo = ciclo() { raiz.agregarHijo(subNodo); }) |
    (subNodo = condicional() { raiz.agregarHijo(subNodo); }) |
    (subNodo = llamadaFuncion() { raiz.agregarHijo(subNodo); }) |
    (subNodo = declaracionFuncion() { raiz.agregarHijo(subNodo); })
  )*
  <LLAVEDER> <FIN>
  <EOF>
  { astRaiz = raiz; return raiz; }
}

NodoAST declaracion() :
{ Token tipo, id; NodoAST nodo; NodoAST nodoExpr = null; }
{
  <VAR>
  (tipo = <ENT> | tipo = <FLOT> | tipo = <BOOL> | tipo = <CAD>)
  id = <IDENTIFICADOR>
  {
    nodo = new NodoAST(id.image, "declaracion_" + tipo.image);
    if (existeVariable(id.image)) {
      agregarErrorSemantico("Error semántico: Variable '" + id.image + "' ya declarada");
    } else {
      agregarVariable(id.image, tipo.image);
    }
  }
  (
    <IGUAL> nodoExpr = expresion()
    {
      nodo.agregarHijo(nodoExpr);
      if (!sonTiposCompatibles(tipo.image, nodoExpr.getTipo())) {
        agregarErrorSemantico("Error semántico: No se puede asignar un valor de tipo '" + nodoExpr.getTipo() +
                              "' a una variable de tipo '" + tipo.image + "'");
      }
    }
  )?
  <DELIMITADOR>
  { return nodo; }
}

NodoAST asignacion() :
{ Token id; NodoAST nodo; NodoAST nodoExpr; String tipoVar; }
{
  id = <IDENTIFICADOR>
  {
    nodo = new NodoAST(id.image, "asignacion");
    if (!existeVariable(id.image)) {
      agregarErrorSemantico("Error semántico: Variable '" + id.image + "' no declarada");
      tipoVar = "desconocido";
    } else {
      tipoVar = obtenerTipo(id.image);
    }
  }
  <IGUAL> nodoExpr = expresion()
  {
    nodo.agregarHijo(nodoExpr);
    if (existeVariable(id.image) && !sonTiposCompatibles(tipoVar, nodoExpr.getTipo())) {
      agregarErrorSemantico("Error semántico: No se puede asignar un valor de tipo '" + nodoExpr.getTipo() +
                            "' a una variable de tipo '" + tipoVar + "'");
    }
  }
  <DELIMITADOR>
  { return nodo; }
}

NodoAST expresion() :
{ NodoAST nodoIzq, nodoDer; NodoAST nodoOp = null; }
{
  nodoIzq = termino()
  (
    { String op = null; }
    ( <MAS> { op = "mas"; } | <MENOS> { op = "menos"; } | <MULT> { op = "mult"; } | <DIV> { op = "div"; }
    | <RES> { op = "res"; } | <AND> { op = "and"; } | <OR> { op = "or"; } | <CONCATENAR> { op = "concatenar"; } )
    nodoDer = termino()
    {
      nodoOp = new NodoAST(op, "operador");
      nodoOp.agregarHijo(nodoIzq);
      nodoOp.agregarHijo(nodoDer);
      nodoIzq = nodoOp;
    }
  )*
  { return nodoIzq; }
}

NodoAST termino() :
{ Token valor = null, id = null; NodoAST nodo; }
{
  (
    valor = <ENTEROS> { nodo = new NodoAST(valor.image, "ent"); }
  |
    valor = <NUMERODECIMAL> { nodo = new NodoAST(valor.image, "flot"); }
  |
    valor = <VCAD> { nodo = new NodoAST(valor.image, "cad"); }
  |
    <PARENIZQ> nodo = expresion() <PARENDER>
  |
    LOOKAHEAD(2) nodo = llamadaFuncion()
  |
    id = <IDENTIFICADOR>
    {
      if (!existeVariable(id.image)) {
        agregarErrorSemantico("Error semántico: Variable '" + id.image + "' no declarada");
        nodo = new NodoAST(id.image, "desconocido");
      } else {
        nodo = new NodoAST(id.image, obtenerTipo(id.image));
      }
    }
  )
  { return nodo; }
}
NodoAST ciclo() :
{ NodoAST nodo; }
{
  (nodo = cicloFor()) | (nodo = cicloWhile())
  { return nodo; }
}

NodoAST cicloFor() :
{ NodoAST nodo = new NodoAST("for", "ciclo"); NodoAST declAsig, cond, inc; }
{
  <FOR> <PARENIZQ>
  (declAsig = declaracion() | declAsig = asignacion()) { nodo.agregarHijo(declAsig); }
  cond = condicion() { nodo.agregarHijo(cond); }
  <DELIMITADOR>
  inc = incremento() { nodo.agregarHijo(inc); }
  <PARENDER>
  { NodoAST bloqueNodo = bloque(); nodo.agregarHijo(bloqueNodo); }
  { return nodo; }
}

NodoAST cicloWhile() :
{ NodoAST nodo = new NodoAST("while", "ciclo"); }
{
  <WHILE> <PARENIZQ>
  { NodoAST cond = condicion(); nodo.agregarHijo(cond); }
  <PARENDER>
  { NodoAST bloqueNodo = bloque(); nodo.agregarHijo(bloqueNodo); }
  { return nodo; }
}

NodoAST condicion() :
{ Token id1 = null, id2 = null; NodoAST nodoIzq, nodoDer, nodoOp; String op; }
{
  (
    id1 = <IDENTIFICADOR>
    {
      if (!existeVariable(id1.image)) {
        agregarErrorSemantico("Error semántico: Variable '" + id1.image + "' no declarada");
        nodoIzq = new NodoAST(id1.image, "desconocido");
      } else {
        nodoIzq = new NodoAST(id1.image, obtenerTipo(id1.image));
      }
    }
  | <ENTEROS> { nodoIzq = new NodoAST(token.image, "ent"); }
  | <NUMERODECIMAL> { nodoIzq = new NodoAST(token.image, "flot"); }
  )
  (
    <IGUALDAD> { op = "=="; } | <DESIGUALDAD> { op = "!="; } | <MAYOR> { op = ">"; }
  | <MENOR> { op = "<"; } | <MAYORIGUAL> { op = ">="; } | <MENORIGUAL> { op = "<="; }
  ) { nodoOp = new NodoAST(op, "comparador"); }
  (
    id2 = <IDENTIFICADOR>
    {
      if (!existeVariable(id2.image)) {
        agregarErrorSemantico("Error semántico: Variable '" + id2.image + "' no declarada");
        nodoDer = new NodoAST(id2.image, "desconocido");
      } else {
        nodoDer = new NodoAST(id2.image, obtenerTipo(id2.image));
      }
    }
  | <ENTEROS> { nodoDer = new NodoAST(token.image, "ent"); }
  | <NUMERODECIMAL> { nodoDer = new NodoAST(token.image, "flot"); }
  )
  {
    nodoOp.agregarHijo(nodoIzq);
    nodoOp.agregarHijo(nodoDer);
    return nodoOp;
  }
}

void operadorComparacion() :
{}
{
  <IGUALDAD> | <DESIGUALDAD> | <MAYOR> | <MENOR> | <MAYORIGUAL> | <MENORIGUAL>
}

NodoAST incremento() :
{ Token id; NodoAST nodo; String op; }
{
  id = <IDENTIFICADOR>
  {
    if (!existeVariable(id.image)) {
      agregarErrorSemantico("Error semántico: Variable '" + id.image + "' no declarada");
      nodo = new NodoAST(id.image, "desconocido");
    } else if (!obtenerTipo(id.image).equals("ent") && !obtenerTipo(id.image).equals("flot")) {
      agregarErrorSemantico("Error semántico: El incremento solo se puede aplicar a variables numéricas");
      nodo = new NodoAST(id.image, "desconocido");
    } else {
      nodo = new NodoAST(id.image, obtenerTipo(id.image));
    }
  }
  ( <INC> { op = "inc"; } | <DEC> { op = "dec"; } )
  {
    NodoAST nodoOp = new NodoAST(op, "incremento");
    nodoOp.agregarHijo(nodo);
    return nodoOp;
  }
}

NodoAST bloque() :
{ NodoAST nodo = new NodoAST("bloque", "bloque"); NodoAST subNodo; }
{
  <LLAVEIZQ>
  (
    (subNodo = declaracion() { nodo.agregarHijo(subNodo); }) |
    (subNodo = asignacion() { nodo.agregarHijo(subNodo); }) |
    (subNodo = ciclo() { nodo.agregarHijo(subNodo); }) |
    (subNodo = condicional() { nodo.agregarHijo(subNodo); }) |
    (subNodo = llamadaFuncion() { nodo.agregarHijo(subNodo); })
  )*
  <LLAVEDER>
  { return nodo; }
}

NodoAST condicional() :
{ NodoAST nodo = new NodoAST("si", "condicional"); NodoAST cond, bloqueSi, bloqueSino = null; }
{
  <SI> <PARENIZQ>
  cond = condicion() { nodo.agregarHijo(cond); }
  <PARENDER>
  bloqueSi = bloque() { nodo.agregarHijo(bloqueSi); }
  (
    <SINO> bloqueSino = bloque() { nodo.agregarHijo(bloqueSino); }
  )?
  { return nodo; }
}

// Modificamos llamadaFuncion() para evitar conflictos y devolver el tipo
NodoAST llamadaFuncion() :
{ Token id = null; NodoAST nodo; }
{
  (
    LOOKAHEAD(2)
    (<MATHFUNC> { nodo = new NodoAST("MathFunc", "flot"); }) |
    (<RAMDONFUNC> { nodo = new NodoAST("RandomFunc", "ent"); }) |
    (<ARRAYFUNC> { nodo = new NodoAST("ArrayFunc", "void"); }) |
    (<TIMERFUNC> { nodo = new NodoAST("TimerFunc", "void"); }) |
    (<LEER> { nodo = new NodoAST("leer", "cad"); }) |
    (<ESCRIBIR> { nodo = new NodoAST("escribir", "void"); }) |
    (id = <IDENTIFICADOR>
     { nodo = new NodoAST(id.image, "llamada_funcion"); })
  )
  <PARENIZQ> (parametrosLlamada(nodo)) <PARENDER> <DELIMITADOR>
  { return nodo; }
}

void parametrosLlamada(NodoAST nodoPadre) :
{ NodoAST param; }
{
  param = expresion() { nodoPadre.agregarHijo(param); }
  (<COMA> param = expresion() { nodoPadre.agregarHijo(param); })*
}
  NodoAST declaracionFuncion() :
  { Token tipo, id; NodoAST nodo; NodoAST params = null; }
  {
    (
      <PROC> { nodo = new NodoAST("proc", "declaracion_funcion"); } |
      <FUNC> { nodo = new NodoAST("func", "declaracion_funcion"); }
    )
    (tipo = <VOID> | tipo = <ENT> | tipo = <FLOT> | tipo = <BOOL> | tipo = <CAD>)
    id = <IDENTIFICADOR>
    { nodo = new NodoAST(id.image, nodo.getTipo() + "_" + tipo.image); }
    <PARENIZQ>
    (params = parametrosDeclaracion() { nodo.agregarHijo(params); })?
    <PARENDER>
    { NodoAST bloqueNodo = bloqueFuncion(); nodo.agregarHijo(bloqueNodo); }
    { return nodo; }
  }

  NodoAST parametrosDeclaracion() :
  { Token tipo, id; NodoAST nodo = new NodoAST("parametros", "parametros"); }
  {
    (tipo = <ENT> | tipo = <FLOT> | tipo = <BOOL> | tipo = <CAD> | tipo = <VAR>)
    id = <IDENTIFICADOR>
    {
      NodoAST param = new NodoAST(id.image, tipo.image);
      nodo.agregarHijo(param);
      agregarVariable(id.image, tipo.image);
    }
    (
      <COMA>
      { NodoAST subParams = parametrosDeclaracion();
        for (NodoAST hijo : subParams.getHijos()) { nodo.agregarHijo(hijo); } }
    )?
    { return nodo; }
  }

  NodoAST bloqueFuncion() :
  { NodoAST nodo = new NodoAST("bloque", "bloque_funcion"); NodoAST subNodo; }
  {
    <LLAVEIZQ>
    (
      (subNodo = declaracion() { nodo.agregarHijo(subNodo); }) |
      (subNodo = asignacion() { nodo.agregarHijo(subNodo); }) |
      (subNodo = ciclo() { nodo.agregarHijo(subNodo); }) |
      (subNodo = condicional() { nodo.agregarHijo(subNodo); }) |
      (subNodo = llamadaFuncion() { nodo.agregarHijo(subNodo); })
    )*
    (subNodo = retorno() { nodo.agregarHijo(subNodo); })?
    <LLAVEDER>
    { return nodo; }
  }

  NodoAST retorno() :
  { NodoAST nodo = new NodoAST("return", "retorno"); NodoAST expr; }
  {
    <RETURN>
    expr = expresion() { nodo.agregarHijo(expr); }
    <DELIMITADOR>
    { return nodo; }
  }